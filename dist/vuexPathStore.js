import t from"vuex";import r from"vue";function n(t){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function o(t){return function(t){if(Array.isArray(t))return e(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||function(t,r){if(!t)return;if("string"==typeof t)return e(t,r);var n=Object.prototype.toString.call(t).slice(8,-1);"Object"===n&&t.constructor&&(n=t.constructor.name);if("Map"===n||"Set"===n)return Array.from(t);if("Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return e(t,r)}(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function e(t,r){(null==r||r>t.length)&&(r=t.length);for(var n=0,o=new Array(r);n<r;n++)o[n]=t[n];return o}function i(t){return!isNaN(t)&&!isNaN(parseFloat(t))}function a(t){return Array.isArray(t)}function u(t){for(var r,n=/(\w+)|\[([^\]]+)\]/g,o=[];r=n.exec(t||"");)"["===t[r.index]?o.push(r[2]):o.push(r[1]);return o}function f(t,r){for(var n=u(r),o=n.length,e=0;e<o;e++){if(void 0===t[n[e]])return;t=t[n[e]]}return t}var c=function(t,o,e){for(var f=u(o),c=f.length,s=c-1,l=0;l<c;l++){var p=f[l];if(l!==s){var y=t[p];y&&"object"===n(y)?(y.hasOwnProperty("__ob__")||r.set(t,p,y),a(y)&&!i(f[l+1])&&r.set(t,p,{})):i(f[l+1])?r.set(t,p,[]):r.set(t,p,{})}else r.set(t,p,e);t=t[p]}},s=function(t,r,o){if("string"==typeof r)c(t,r,o);else{if(!function(t){return"object"===n(t)&&!Array.isArray(t)&&null!==t}(r))throw Error("Arguments must be either string or object.");for(var e in r)c(t,e,r[e])}},l=["pop","push","reverse","shift","sort","splice","unshift"],p=function(r){var n={set:function(t,r){var n=r.path,o=r.value;s(t,n,o)},toggle:function(t,r){var n=r.path;c(t,n,!f(t,n))}};l.forEach((function(t){n[t]=function(r,n){var e=n.path,i=n.args,u=f(r,e);if(!a(u))throw Error("Argument must be an array");u[t].apply(u,o(i))}})),r.mutations=Object.assign({},r.mutations||{},n);var e=new t.Store(r);return e.set=function(t,r){e.commit("set",{path:t,value:r})},e.toggle=function(t){e.commit("toggle",{path:t})},l.forEach((function(t){e[t]=function(){for(var r=arguments.length,n=new Array(r),o=0;o<r;o++)n[o]=arguments[o];var i=n.shift();e.commit(t,{path:i,args:n})}})),e};export{p as createVuexPathStore};
